# -*- coding: utf-8 -*-
"""hw2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o8KUS0qmWDxQvtesTVWhsI32ZZtHIQO2
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import skew, kurtosis

# Constants
annual_trading_days = 252
monthly_trading_days = 12

# Download historical data for ^GSPC (S&P 500) from 1995-01-01 to 2024-09-01
gspc = yf.download('^GSPC', start='1995-01-01', end='2024-09-01')

# Calculate daily returns
gspc['Returns'] = gspc['Close'].pct_change()

# Annualization factor for returns
annual_factor = 252

# Group by Year
gspc['Year'] = gspc.index.year
yearly_group = gspc.groupby('Year')['Returns'].agg(['mean', 'std'])
yearly_group['mean'] *= annual_factor
yearly_group['std'] *= np.sqrt(annual_factor)

# Group by Month of Year
gspc['Month'] = gspc.index.month
monthly_group = gspc.groupby('Month')['Returns'].agg(['mean', 'std'])
monthly_group['mean'] *= annual_factor
monthly_group['std'] *= np.sqrt(annual_factor)

# Group by Day of the Week
gspc['Day of Week'] = gspc.index.dayofweek
weekly_group = gspc.groupby('Day of Week')['Returns'].agg(['mean', 'std'])
weekly_group['mean'] *= annual_factor
weekly_group['std'] *= np.sqrt(annual_factor)

# Print the results
print("Yearly Returns:")
print(yearly_group)

print("\nMonthly Returns:")
print(monthly_group)

print("\nWeekly Returns:")
print(weekly_group)

# Comments on the tables
print("Comment: The yearly returns seem to follow a pattern of growth during bull markets and declines during bear markets. Monthly returns are positive in most months, with some seasonality. Weekly returns show that Mondays tend to have lower returns, likely due to weekend effect.")

# Function to calculate rolling alpha and beta
def calculate_alpha_beta(stock_returns, market_returns, window):
    cov_matrix = stock_returns.rolling(window).cov(market_returns)
    market_var = market_returns.rolling(window).var()
    beta = cov_matrix / market_var
    alpha = stock_returns.rolling(window).mean() - beta * market_returns.rolling(window).mean()
    return alpha, beta

# Tickers to analyze
tickers = ['AAPL', 'NVDA', 'GME', 'WMT', 'GS', 'MCD']

# Download data for ^GSPC (market) and the selected tickers
data = yf.download(tickers + ['^GSPC'], start='1995-01-01', end='2024-09-01', interval='1mo', progress=False)

# Extract adjusted close prices
adj_close = data['Adj Close']

# Compute monthly returns for the selected stocks and ^GSPC
returns = adj_close.pct_change().dropna()

# Separate market returns (^GSPC) and stock returns
market_returns = returns['^GSPC']
stock_returns = returns.drop(columns='^GSPC')

# Set rolling window for 5 years (60 months)
window = 60

# Initialize dictionaries to hold the rolling alpha and beta for each stock
rolling_alpha = {}
rolling_beta = {}

# Calculate rolling alpha and beta for each stock
for ticker in tickers:
    alpha, beta = calculate_alpha_beta(stock_returns[ticker], market_returns, window)
    rolling_alpha[ticker] = alpha
    rolling_beta[ticker] = beta

# Convert dictionaries to DataFrames for easier plotting
rolling_alpha_df = pd.DataFrame(rolling_alpha)
rolling_beta_df = pd.DataFrame(rolling_beta)

# Plot the rolling alpha through time for all tickers
plt.figure(figsize=(14, 7))
for ticker in tickers:
    plt.plot(rolling_alpha_df.index, rolling_alpha_df[ticker], label=f'{ticker} Alpha')
plt.title('Rolling 5-Year Alpha through Time')
plt.xlabel('Date')
plt.ylabel('Alpha')
plt.legend()
plt.show()

# Plot the rolling beta through time for all tickers
plt.figure(figsize=(14, 7))
for ticker in tickers:
    plt.plot(rolling_beta_df.index, rolling_beta_df[ticker], label=f'{ticker} Beta')
plt.title('Rolling 5-Year Beta through Time')
plt.xlabel('Date')
plt.ylabel('Beta')
plt.legend()
plt.show()

# --- FIX for 'AAPL' error from previous code ---

# Download historical data for AAPL only (single ticker to avoid KeyError)
aapl = yf.download('AAPL', start='1980-01-01', end='2024-09-01')

# Check if the data was downloaded properly
print(aapl.head())

# Calculate daily log returns for AAPL
aapl['Log Returns'] = np.log(aapl['Close'] / aapl['Close'].shift(1)).dropna()

# Compute summary statistics for AAPL (annualized)
annual_trading_days = 252
mean_return = aapl['Log Returns'].mean() * annual_trading_days
std_return = aapl['Log Returns'].std() * np.sqrt(annual_trading_days)
skewness = skew(aapl['Log Returns'].dropna())
kurt = kurtosis(aapl['Log Returns'].dropna(), fisher=False)

# Print summary statistics for AAPL
print(f"AAPL Annualized Mean: {mean_return}")
print(f"AAPL Annualized Std Dev: {std_return}")
print(f"AAPL Skewness: {skewness}")
print(f"AAPL Kurtosis: {kurt}")

# Plot daily log returns for AAPL
plt.figure(figsize=(10, 6))
plt.plot(aapl.index, aapl['Log Returns'], label='AAPL Log Returns')
plt.title('Daily Log Returns of AAPL')
plt.xlabel('Date')
plt.ylabel('Log Returns')
plt.legend()
plt.show()

# Plot rolling 6-month volatility
aapl['Rolling Volatility'] = aapl['Log Returns'].rolling(window=126).std() * np.sqrt(annual_trading_days)
plt.figure(figsize=(10, 6))
plt.plot(aapl.index, aapl['Rolling Volatility'], label='AAPL Rolling 6-Month Volatility')
plt.title('Rolling 6-Month Volatility of AAPL')
plt.xlabel('Date')
plt.ylabel('Volatility')
plt.legend()
plt.show()

# Download AAPL's daily price history
aapl = yf.download('AAPL', start='1980-01-01', end='2024-09-01')

# Calculate daily log returns
aapl['Log Returns'] = np.log(aapl['Close'] / aapl['Close'].shift(1)).dropna()

# Compute summary statistics
mean_return = aapl['Log Returns'].mean() * annual_trading_days
std_return = aapl['Log Returns'].std() * np.sqrt(annual_trading_days)
skewness = skew(aapl['Log Returns'].dropna())
kurt = kurtosis(aapl['Log Returns'].dropna(), fisher=False)  # Use Pearson's definition

# Print summary statistics
print(f"Annualized Mean: {mean_return}")
print(f"Annualized Std Dev: {std_return}")
print(f"Skewness: {skewness}")
print(f"Kurtosis: {kurt}")

# Plot daily log returns
plt.figure(figsize=(10, 6))
plt.plot(aapl.index, aapl['Log Returns'], label='AAPL Log Returns')
plt.title('Daily Log Returns of AAPL')
plt.xlabel('Date')
plt.ylabel('Log Returns')
plt.legend()
plt.show()

# Plot rolling 6-month volatility
aapl['Rolling Volatility'] = aapl['Log Returns'].rolling(window=126).std() * np.sqrt(annual_trading_days)
plt.figure(figsize=(10, 6))
plt.plot(aapl.index, aapl['Rolling Volatility'], label='AAPL Rolling 6-Month Volatility')
plt.title('Rolling 6-Month Volatility of AAPL')
plt.xlabel('Date')
plt.ylabel('Volatility')
plt.legend()
plt.show()

# Comments on the statistics and plots
print("Comment: AAPL shows periods of high volatility, especially during market crises, with positive skewness and excess kurtosis. This reflects its growth nature and sensitivity to market cycles.")

# Parameters for simulation
mu = mean_return
sigma = std_return
num_periods = len(aapl)
num_simulations = 1000

# Simulate returns using geometric Brownian motion
simulated_returns = np.random.normal(loc=(mu / annual_trading_days), scale=(sigma / np.sqrt(annual_trading_days)), size=(num_periods, num_simulations))

# Compute summary statistics for simulated returns
sim_mean = simulated_returns.mean() * annual_trading_days
sim_std = simulated_returns.std() * np.sqrt(annual_trading_days)
sim_skew = skew(simulated_returns)
sim_kurt = kurtosis(simulated_returns, fisher=False)

# Print summary statistics for simulated returns
print(f"Simulated Annualized Mean: {sim_mean}")
print(f"Simulated Annualized Std Dev: {sim_std}")
print(f"Simulated Skewness: {sim_skew}")
print(f"Simulated Kurtosis: {sim_kurt}")

# Plot one path of simulated returns
plt.figure(figsize=(10, 6))
plt.plot(aapl.index, np.cumsum(simulated_returns[:, 0]), label='Simulated Returns')
plt.plot(aapl.index, np.cumsum(aapl['Log Returns']), label='Actual AAPL Returns', linestyle='--')
plt.title('Simulated vs Actual Daily Log Returns')
plt.xlabel('Date')
plt.ylabel('Cumulative Log Returns')
plt.legend()
plt.show()

# Plot rolling volatility for one simulation
simulated_vol = pd.Series(simulated_returns[:, 0]).rolling(window=126).std() * np.sqrt(annual_trading_days)
plt.figure(figsize=(10, 6))
plt.plot(aapl.index, simulated_vol, label='Simulated Rolling 6-Month Volatility')
plt.plot(aapl.index, aapl['Rolling Volatility'], label='Actual Rolling Volatility', linestyle='--')
plt.title('Simulated vs Actual Rolling 6-Month Volatility')
plt.xlabel('Date')
plt.ylabel('Volatility')
plt.legend()
plt.show()

# Comments on the simulation and fit
print("Comment: The simulated returns show a similar drift and volatility pattern, but the real AAPL returns have more extreme fluctuations due to market shocks that the model doesn't capture well.")

# Value at Risk (VaR) and Conditional Tail Expectation (CTE)
VaR_95 = np.percentile(aapl['Log Returns'].dropna(), 5)
VaR_99 = np.percentile(aapl['Log Returns'].dropna(), 1)

CTE_95 = aapl['Log Returns'][aapl['Log Returns'] <= VaR_95].mean()
CTE_99 = aapl['Log Returns'][aapl['Log Returns'] <= VaR_99].mean()

print(f"VaR(95): {VaR_95}")
print(f"VaR(99): {VaR_99}")
print(f"CTE(95): {CTE_95}")
print(f"CTE(99): {CTE_99}")

# Count of 6-sigma events
mean_log = aapl['Log Returns'].mean()
std_log = aapl['Log Returns'].std()

six_sigma_events_actual = (aapl['Log Returns'] <= (mean_log - 6 * std_log)).sum()
six_sigma_events_simulated = (simulated_returns <= (mean_log - 6 * std_log)).sum()

print(f"6-Sigma Events in Actual Returns: {six_sigma_events_actual}")
print(f"6-Sigma Events in Simulated Returns: {six_sigma_events_simulated}")

# Model evaluation comments
print("Comment: The model captures general drift and volatility but underestimates tail risk and extreme events, which may lead to underestimation of portfolio risk in real-world scenarios.")